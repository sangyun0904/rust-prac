# OWNERSHIP 이란 

***Rust의 Ownership이란 메모리를 어떻게 관리할 것인지에 대한 규칙들이다. 다른 어떤 언어들은 사용하지 않는 메모리를 자동으로 정리해 주는 garbage collection 이라는 것을 가기고 있고, 또 어떤 언어들은 개발자가 직접 메모리를 할당하고 비워주는 방식으로 메모리를 관리해 주어야 한다. 그러나 Rust는 system of ownership이라는 여러가지 룰들을 컴파일러가 확인한 후에 프로그램을 실행하는 식으로 메모리를 관리한다.***

## The Stack and the Heap 

여타 다른 프로그래밍 언어들은 개발자에게 stack과 heap에 대해 많이 고민하게 요구하지 않는다. 그러나 Rust와 같은 언어에서 값이 stack에 들어있는지 혹은 heap에 들어있는지에 따라 언어가 동작하는 방식이 달라진다. 

Stack 과 Heap 은 모두 런타임에 코드를 실행시키기 위해 사용되는 메모리의 한 부분이다. 그러나 이 둘은 다르게 구성되어 있다.

먼저 Stack은 데이터를 들어오는 순서대로 저장하고 역순으로 데이터를 지운다. 즉, LIFO (Last In First Out) 방식으로 동작한다. stack에 데이터를 추가하는 것을 push한다고 하고 데이터를 빼는것은 pop이라고 한다. **Stack에 저장되는 모든 데이터는 고정된 알려진 크기여야 한다. 컴파일 타임에 크기를 알지 못하는 데이터는 stack이 아니라 heap에 저장되어야 한다.**

반대로 heap은 덜 정돈되어 있다. heap에 데이터를 집어넣을 때 개발자는 어느정도 크기의 공간을 프로그램에 요구한다. 그러면 memory allocator가 heap에서 충분한 사이즈의 공간을 찾고 그곳을 가리키는 pointer를 리턴한다. 이 과정을 allocation on the heap이라 하고 줄여서 allocation이라고 한다. (stack에 데이터를 push 하는것은 allocating이라고 하지 않는다.) 리턴된 pointer는 고정된 크기이기 때문에 stack에 저장될 수 있다. 그러나 실제 데이터는 그 포인터가 가리키는 주소를 따라가야 한다. 

stack에 데이터를 push하는 것이 heap에 데이터를 allocate하는 것보다 빠르다. 비어있는 공간을 찾을 필요가 없기 때문이다. stack에 대이터를 push할때는 항상 가장 위쪽부터 차곡차곡 데이터를 쌓는다. 반대로 heap에 데이터를 저장할 때는 충분한 공간을 먼저 찾아야하고, 또한 실제 데이터가 저장될 때 까지 그 공간을 붙들고 있어야 한다. 

heap에 데이터에 접근하는 것은 stack에 데이터에 접근하는것보다 느리다. 그 이유는 heap에 데이터는 pointer를 따라가야 하기 때문이다. heap에는 데이터가 무작위적으로 분산되어 있다. 그러나 stack은 데이터가 차곡차곡 쌓여있다. heap에 있는 데이터를 여러개 조회할 때 훨씬 더 많은 공간을 이동해야 한다. 

코드가 함수를 실행할 때 (그 데이터는 주로 heap에 있는 데이터를 가리키는 pointer일 것이다.) 그러면 함수의 로컬 변수가되어 stack에 push 된다. 그리고 함수가 끝나면 그 데이터는 pop되어 stack을 빠져나간다.  

코드의 어떤 부분이 heap의 데이터를 사용하는지, heap에 중복된 데이터가 많지는 않은지, heap에 사용하지 않는 데이터가 남아있는지 등이 ownership이 다루는 문제이다. ownership을 잘 이해하면 heap과 stack에 많은 신경을 쓰지 않울 수 있다. 그러나 ownership에 목적이 heap 데이터를 관리하는 것이라는 것을 이해하는것은 ownership의 동작 과정을 이해하는데 큰 도움이 된다. 